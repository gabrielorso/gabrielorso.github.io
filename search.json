[
  {
    "objectID": "silvtropical.html",
    "href": "silvtropical.html",
    "title": "Dendrometria",
    "section": "",
    "text": "Plano de Ensino\nGuia de Estudo\n\nConteúdo Programático\n\n\n\n\n\n\n\nData\nConteúdo\nMateriais\n\n\n\n\n06/02/2025\n\nApresentação da disciplina: Ementa, cronograma e avaliações.\nIntrodução à Silvicultura Tropical.\n\n\n\n\n13/02/2025\nIntrodução aos Sistemas Silviculturais. Domesticação Florestal. Sistemas policíclicos e monicíclicos. Métodos de transformação: Sistema de melhoramento e Sistema de enriquecimento.\n\n\n\n20/02/2025\nFlorestas sustentáveis.\n\n\n\n27/02/2025\nCertificação florestal. Trabalho prático: Silvicultura aplicada em espécies florestais.\n\n\n\n06/03/2025\nFormações florestais nos trópicos - Trabalho.\n\n\n\n13/03/2025\nVerificação de aprendizagem I\n\n\n\n20/03/2025\nMétodo de substituição: Sistema silvicultural de talhadia.\n\n\n\n27/03/2025\nTratamentos silviculturais aplicáveis ao manejo de florestasl.\n\n\n\n03/04/2025\nPráticas silviculturais e culturais aplicados às florestas tropicais.\n\n\n\n10/04/2025\nFormações florestais do Brasil e Mato Grosso.\n\n\n\n17/04/2025\nTrabalho avaliativo: Práticas silviculturais e culturais em espécies florestais.\n\n\n\n24/04/2025\nImplantação de povoamentos florestais com nativas e exóticas (Trabalho).\n\n\n\n01/05/2025\nSilvicultura de nativas e exóticas no Brasil.\n\n\n\n08/05/2025\nVerificação de aprendizagem II\n\n\n\n15/05/2025\nVista de prova. Revisão dos conteúdos abordados. Fechamento da disciplina.\n\n\n\n22/05/2025\nExame final"
  },
  {
    "objectID": "motores.html",
    "href": "motores.html",
    "title": "Motores, Máquinas e Implementos Florestais.",
    "section": "",
    "text": "Plano de Ensino\nGuia de Estudo\n\nConteúdo Programático\n\n\nData\nConteúdo\nMateriais\n\n\n\n\n03/02/2025\n\n1 Apresentação do plano de ensino da disciplina, guia de estudos e Introdução à disciplina.\n2 Fontes de energia utilizadas na agricultura.\n\n\nAula 1\nAula 2 | Material Complementar I | Material Complementar II\n\n\n\n10/02/2025\n\n3 Tipos de motores.\n4 Motores de combustão interna\n\n\n\n\n17/02/2025\nSistemas complementares.\n\n\n\n24/02/2025\nCálculo de potência.\n\n\n\n03/03/2025\nCarnaval - Sem aula\n\n\n\n10/03/2025\nRevisão para verificação de aprendizagem I\n\n\n\n17/03/2025\nVerificação de aprendizagem I\n\n\n\n24/03/2025\nProjetos, especificações técnicas e princípios de funcionamento das máquinas e equipamentos usados no setor.\n\n\n\n31/03/2025\nDesempenho dos tratores florestais.\n\n\n\n07/04/2025\nLastros, bitola, pneus e lubrificantes.\n\n\n\n14/04/2025\n\nMecanização na silvicultura e na colheita.\nSorteio do tema do trabalho.\n\n\n\n\n21/04/2025\nFeriado de Tiradentes - Sem aula.\n\n\n\n28/04/2025\nRevisão para verificação de aprendizagem II.\n\n\n\n05/05/2025\nVerificação de aprendizagem II.\n\n\n\n12/05/2025\nApresentação dos trabalhos.\n\n\n\n19/05/2025\nExame final."
  },
  {
    "objectID": "ggplot.html",
    "href": "ggplot.html",
    "title": "Visualização de Dados Florestais no R",
    "section": "",
    "text": "library(ggplot2)\nlibrary(ggcorrplot)\nlibrary(ggthemes)\nlibrary(gridExtra)\nlibrary(MASS)\nlibrary(ggalt)\n# Para instalar os pacotes, use install.packages('ggplot2'), e \n# da mesma forma com os outros.\n\ndados.brutos &lt;- read.csv2(\"data/dados.csv\",\n                   header = TRUE,\n                   sep = \";\",\n                   dec = \",\")\n\nstr(dados.brutos)\n\n'data.frame':   100 obs. of  15 variables:\n $ ua     : int  24 149 89 114 5 35 105 138 93 117 ...\n $ projeto: chr  \"Campo Alto\" \"Campina\" \"Campina\" \"Lageadinho\" ...\n $ npragas: int  2 0 2 4 0 3 0 4 1 3 ...\n $ idade  : num  12 7.6 8.5 4.5 10 5.5 4.5 4 6.5 5.5 ...\n $ nha    : int  1444 2246 1900 3600 1050 1593 2800 4185 2800 2700 ...\n $ vha    : num  134 65.9 77 49.1 77 ...\n $ gha    : num  18.96 11.81 12.67 8.29 13.14 ...\n $ d      : num  12.4 7.9 8.8 8.6 12 7.6 8.8 6 8.2 8.7 ...\n $ h      : num  13.7 10.5 11.7 11.6 11.3 ...\n $ v      : num  0.0927 0.03 0.0405 0.0369 0.0733 0.0254 0.0274 0.01 0.0302 0.0327 ...\n $ g      : num  0.013 0.01 0.007 0.006 0.013 0.005 0.007 0 0.006 0.006 ...\n $ dg     : num  12.9 8.2 9.2 8.9 12.6 7.8 9.2 6.4 8.5 8.9 ...\n $ hdom   : num  15.6 12.6 13 13 12.6 ...\n $ sitio  : int  12 12 12 14 10 12 10 14 12 10 ...\n $ classe : chr  \"Classe II\" \"Classe II\" \"Classe II\" \"Classe I\" ...\n\n# View(dados.brutos)\n\nggplot(dados.brutos, aes(d,v)) + geom_point()\n\nWarning: Removed 6 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n# Removendo as linhas com valores ausentes\ndados &lt;- subset(dados.brutos,!is.na(dados.brutos$d))\n\nstr(dados)\n\n'data.frame':   94 obs. of  15 variables:\n $ ua     : int  24 149 89 114 5 35 105 138 93 117 ...\n $ projeto: chr  \"Campo Alto\" \"Campina\" \"Campina\" \"Lageadinho\" ...\n $ npragas: int  2 0 2 4 0 3 0 4 1 3 ...\n $ idade  : num  12 7.6 8.5 4.5 10 5.5 4.5 4 6.5 5.5 ...\n $ nha    : int  1444 2246 1900 3600 1050 1593 2800 4185 2800 2700 ...\n $ vha    : num  134 65.9 77 49.1 77 ...\n $ gha    : num  18.96 11.81 12.67 8.29 13.14 ...\n $ d      : num  12.4 7.9 8.8 8.6 12 7.6 8.8 6 8.2 8.7 ...\n $ h      : num  13.7 10.5 11.7 11.6 11.3 ...\n $ v      : num  0.0927 0.03 0.0405 0.0369 0.0733 0.0254 0.0274 0.01 0.0302 0.0327 ...\n $ g      : num  0.013 0.01 0.007 0.006 0.013 0.005 0.007 0 0.006 0.006 ...\n $ dg     : num  12.9 8.2 9.2 8.9 12.6 7.8 9.2 6.4 8.5 8.9 ...\n $ hdom   : num  15.6 12.6 13 13 12.6 ...\n $ sitio  : int  12 12 12 14 10 12 10 14 12 10 ...\n $ classe : chr  \"Classe II\" \"Classe II\" \"Classe II\" \"Classe I\" ...\n\n#Definindo tema padrao para os gráficos\ntheme_set(theme_bw())"
  },
  {
    "objectID": "ggplot.html#dispersão-entre-variáveis",
    "href": "ggplot.html#dispersão-entre-variáveis",
    "title": "Visualização de Dados Florestais no R",
    "section": "Dispersão entre variáveis",
    "text": "Dispersão entre variáveis\n\nDisposição mais simples\n\ng.base +  #*\n  \n  geom_point() + #Puxa x e y do argumento aes() inserido no gráfico base\n  \n  labs(subtitle = \"Dispersão Volume x DAP\") #Adiciona mais argumentos à função labs()\n\n\n\n\n\n\n\n#* Notar a possibilidade de adicionar mais comandos ao gráfico criado anteriormente\n\n\n\nAdicionando uma terceira variável\n\ng.base + \n  \n  geom_point(aes(color = classe)) + \n  \n  labs(subtitle = \"Adicionando uma terceira variável\")\n\n\n\n\n\n\n\n\n\n\nAdicionando uma quarta variável\n\ng.base + \n  \n  geom_point(aes(color = classe, size = nha)) + \n  \n  labs(subtitle = \"Adicionando uma quarta variável\")  \n\n\n\n\n\n\n\n\n\n\nAdicionando uma variável contínua*\n\ng.base + \n  \n  geom_point(aes(color = idade)) + \n  \n  labs(subtitle = \"Exemplo com variável contínua\")\n\n\n\n\n\n\n\n#* a variável idade pode ser transformada em categorias por meio de factor(idade)\n\n\n\nQuando há muita sobreposição de pontos\n\ng.base &lt;- ggplot(dados, aes(x = idade, y = g)) + labs(x = \"Idade\", y = \"Área Transversal (m²)\")\n\n#Vários pontos estão agrupados na mesma posição\ng.base + geom_point(color = \"darkblue\")\n\n\n\n\n\n\n\n#jitter() \"agita\" os pontos com base no argumento \"width\"\ng.base + geom_jitter(width = 0.1, color = \"firebrick\")\n\n\n\n\n\n\n\n#count() acumula os pontos agrupados e informa na escala quantos pontos estão representado pelo respectivo tamanho.\ng.base + geom_count(color = \"red\")\n\n\n\n\n\n\n\n#Notar que, ao contrário dos gráficos anteriores, o argumento \"color\" foi inserido fora da função \"aes()\". Isso ocorre pois antes as cores iriam variar de acordo com uma variável, e variáveis devem ser mapeadas dentro da função \"aes()\". Como agora foi usada uma cor pré-definida, o argumento \"color\" fica fora da função \"aes()\". Essa lógica se aplica para todas as demais estéticas mapeáveis (color, fill, shape, size, alpha, linewidth, ...)\n\n#Outra opção é atribuir uma transparência aos pontos, criando a sensacao de densidade de pontos. A transparência é definida pelo argumento \"alpha\"\nggplot(dados, aes(x = d, y = v)) + geom_point(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n#Outro exemplo com transparência com o banco de dados \"diamonds\".\n###Pode demorar###\nggplot(diamonds, aes(x = carat, y = price)) + geom_point(alpha = 0.1)"
  },
  {
    "objectID": "ggplot.html#correlograma",
    "href": "ggplot.html#correlograma",
    "title": "Visualização de Dados Florestais no R",
    "section": "Correlograma",
    "text": "Correlograma\nOutra forma de apresentar a relação entre variáveis é por meio de um correlograma.\nNesse caso, será utilizado o pacote ggcorrplot, que possibilita a criação de correlogramas no ggplot2.\n\n#install.packages(\"ggcorrplot\")\n#library(ggcorrplot)\n\n#Calculando a correlação entre as variáveis (apenas as numéricas)\ncorrel &lt;- cor(dados[!is.na(dados$d),c(\"idade\",\"nha\",\"vha\",\"gha\",\"d\",\"h\",\"v\",\"g\",\"dg\",\"hdom\")])\n\n#Arredondando para 1 casa decimal\ncorrel &lt;- round(correl,1) \n\n#Criando o correlograma\n#______________________________________________________________\nggcorrplot(corr = correl,      #Informando a matriz de correlação calculada acima\n           method = \"circle\",  #Forma da visualização\n           type = \"lower\",     #Mostrar apenas a parte inferior da matriz\n           lab = TRUE,lab_size = 3, #Inserir os valores da correlação e o tamanho da fonte\n           colors = c(\"firebrick\",\"white\",\"steelblue\"))#Cores. -1, 0 e 1\n\n\n\n\n\n\n\n#Nesse caso, a escala criada é um tanto redundante, uma vez que os números indicam claramente a ordem das cores no sinal da correlação."
  },
  {
    "objectID": "ggplot.html#histogramas",
    "href": "ggplot.html#histogramas",
    "title": "Visualização de Dados Florestais no R",
    "section": "Histogramas",
    "text": "Histogramas\n\nApenas uma variável\n\ng.base + \n  geom_histogram(bins = 9, fill = \"lightblue\", color = \"red\") # fill != color\n\n\n\n\n\n\n\n#bin é o número de barras ou classes. Outra opção seria utilizar \"binwidth\", que especifica a amplitude da barra ou classe\n\n#Notar que no ggplot o argumento \"color\" se refere à linhas, contornos e traços; enquanto o argumento \"fill\" se refere ao preenchimento de objetos. Normalmente, pontos também não possuem o parâmetro \"fill\", pois, bem, são apenas pontos; com exceção dos formatos (shape) 21-25, que possuem preenchimento. \n\n\n\nIncluindo outra variavel\n\ng.base + \n  geom_histogram(aes(fill = projeto), \n                 bins = 9, \n                 color = \"black\")\n\n\n\n\n\n\n\n\n\n\nHistogramas de variáveis categóricas\nTambem é possível fazer histogramas de variáveis categóricas\n\nggplot(dados) + \n  geom_bar(aes(x = projeto, fill = classe),\n           color = \"black\")\n\n\n\n\n\n\n\n#OU\n\nggplot(dados) + \n  geom_histogram(aes(x = projeto, fill = classe),\n                 color = \"black\",\n                 stat = \"count\")\n\nWarning in geom_histogram(aes(x = projeto, fill = classe), color = \"black\", :\nIgnoring unknown parameters: `binwidth`, `bins`, and `pad`"
  },
  {
    "objectID": "ggplot.html#densidade",
    "href": "ggplot.html#densidade",
    "title": "Visualização de Dados Florestais no R",
    "section": "Densidade",
    "text": "Densidade\nSimilar ao histograma\n\nVersão sem graça\n\ng.base + \n  geom_density()\n\n\n\n\n\n\n\n\n\n\nMais elaborado, e dividindo por classe de sítio\n\ng.base + \n  geom_density(aes(fill = classe), alpha = 0.7)"
  },
  {
    "objectID": "ggplot.html#boxplot",
    "href": "ggplot.html#boxplot",
    "title": "Visualização de Dados Florestais no R",
    "section": "Boxplot",
    "text": "Boxplot\nPor padrão, a função geom_boxplot() recebe apenas uma variável categórica no eixo X e uma contínua no eixo Y. O exemplo abaixo é a fórmula mais simples, e é utilizado o diâmetro no eixo Y.\n\nForma mais simples\n\nggplot(dados) + geom_boxplot(aes(y = d))\n\n\n\n\n\n\n\n\n\n\nAdicionando uma variável categórica\n\nggplot(dados) + \n  geom_boxplot(aes(x = projeto, y = v)) + \n  labs(x = \"Projeto\" , y = \"Volume (m³)\")\n\n\n\n\n\n\n\n\n\n\nEspessura variável\n\nggplot(dados) + \n  geom_boxplot(aes(x = projeto, y = v), varwidth = TRUE) +\n  labs(x = \"Projeto\", y = \"Volume (m³)\")\n\n\n\n\n\n\n\n#O argumento varwidth torna as caixas com espessura proporcional ao número de observações por classe. Mais especificamente, proporcional à raiz quadrada do número de observações.\n\n\n\nTufte Boxplot\nusando o pacote ggthemes.\n\n#install.packages(ggthemes)\n#library(ggthemes)\n\nggplot(dados, ) + \n  geom_tufteboxplot(aes(x = projeto, y = v), size = 1) + \n  labs(x = \"Projeto\", y = \"Volume(m³)\")\n\nWarning: The following aesthetics were dropped during statistical transformation: y.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\n\n\nWarning: Using the `size` aesthetic with geom_segment was deprecated in ggplot2 3.4.0.\nℹ Please use the `linewidth` aesthetic instead.\n\n\n\n\n\n\n\n\n\nDesde a versão 3.4.0, o pacote ggplot2 alterou o argumento para espessura de linhas de size para linewidth, para diferenciar do size que se refere ao tamanho de pontos de geom_point(). Entretanto, a função ggthemes::geom_tufteboxplot() não foi atualizada e mantém a sintaxe de size. Até 22/01/2025 a função ainda funciona."
  },
  {
    "objectID": "ggplot.html#barras",
    "href": "ggplot.html#barras",
    "title": "Visualização de Dados Florestais no R",
    "section": "Barras",
    "text": "Barras\n\nggplot(df.ranking) + \n  geom_bar(aes(x = classe, y = vha), stat = \"identity\") + \n  \n  geom_hline(yintercept = mean(df.ranking$vha), color = \"red\")\n\n\n\n\n\n\n\n#O argumento stat = \"identity\" precisa ser inserido pois caso contrário o ggplot tenteria somar os valores. stat se refere à transformação dos dados, nesse caso, os dados serão usados na forma como estão no data frame.\n\n#Também foi inserida uma linha horizontal, cujo intercepto no eixo Y é a média dos três volumes acima calculados. Isso serve para mostrar que é possível também realizar pequenos cálculos ou transformações nas variáveis mesmo dentro do ambiente do ggplot.\n\nO exemplo acima exemplifica uma situação comum na confecção de gráficos, que é a manipulação e adequação dos dados, para que então possam ser inseridos no ggplot. É imprescindível que o usuário tenha em mente que, para que sejam plotados os valores desejados, esses valores precisam antes ser calculados e arranjados de uma maneira adequada para inclusão no ggplot, tal como no exemplo acima.\n\nBarras coloridas\n\nggplot(df.ranking) + \n  geom_bar(aes(x = classe, y = vha, fill = classe), stat = \"identity\") + \n  labs(x = \"Classe de Sítio\", y = \"Volume (m³/ha)\")\n\n\n\n\n\n\n\n\n\n\nBarras ordenadas\nCaso seja de interesse ordenar as barras na ordem crescente ou decrescente, é preciso realizar dois procedimentos. O primeiro é ordenar o banco de dados na ordem desejada, e o segundo é ordenar os níveis dos fatores (quando presentes) da mesma forma. O segundo passo é necessário pois, mesmo quando os valores estão ordenados, o ggplot dá preferência de plotagem para a ordem dos níveis (que normalmente estão na ordem alfabética). Em outras palavras, o segundo passo “fixa” a nova ordem dos níveis.\n\n#Observe na estrutura do banco de dados `df.ranking` que há três níveis para a variável classe (`\"Classe I\"`, `\"Classe \"II\"`, `\"Classe III\"`)\n\nstr(df.ranking)\n\n'data.frame':   3 obs. of  2 variables:\n $ classe: chr  \"Classe I\" \"Classe II\" \"Classe III\"\n $ vha   : num  106.1 80.2 77.4\n\n#Passo 1 - ordenando o banco de dados com base na variável vha, em ordem crescente\ndf.ranking &lt;- df.ranking[order(df.ranking$vha),]\n\n#Passo 2 - redefinindo os níveis da variável classe na ordem que foram realocados com o ordenamento acima\ndf.ranking$classe &lt;- factor(df.ranking$classe, levels = df.ranking$classe)\n\n#Note como a ordem dos níveis mudou\nstr(df.ranking)\n\n'data.frame':   3 obs. of  2 variables:\n $ classe: Factor w/ 3 levels \"Classe III\",\"Classe II\",..: 1 2 3\n $ vha   : num  77.4 80.2 106.1\n\n#___________________________________________________\nggplot(df.ranking) + \n  geom_bar(aes(x = classe, y = vha, fill = classe), stat = \"identity\") + \n  labs(x = \"Classe de Sítio\", y = \"Volume (m³/ha)\")"
  },
  {
    "objectID": "ggplot.html#gráfico-de-pirulito",
    "href": "ggplot.html#gráfico-de-pirulito",
    "title": "Visualização de Dados Florestais no R",
    "section": "Gráfico de Pirulito",
    "text": "Gráfico de Pirulito\n\nggplot(df.ranking) + \n  geom_point(aes(x = classe, y = vha), size = 9, alpha = 0.7) +\n  \n  geom_segment(aes(x = classe, xend = classe, \n                   y = 50, yend = vha)) + \n  \n  geom_text(aes(x = classe, y = vha, label = round(vha,0)), color = \"white\") +\n  \n  labs(x = \"Classe de Sítio\", y = \"Volume(m³/ha)\") + \n  \n  ylim(50,120)\n\n\n\n\n\n\n\n#geom_segment cria segmentos de reta do ponto (x,y) até o ponto (xend,yend). No exemplo acima, os segmentos de reta, no eixo x, vão de classe até classe, ou seja, não se deslocam no eixo x. E como são 3 classes, são criados três segmentos de reta. Para as posições no eixo Y, foi indicado para os segmentos de reta iniciarem na posição 50, e ir até vha. Como são três valores de vha, são criados três segmentos que vão até seu respectivo valor.\n\n#geom_text insere textos no gráfico. A posição é definida por x e y dentro de aes(), e o texto a ser inserido fica contido em label (rótulo). Como se pode perceber, são fornecidos três valores de x (3 classes), 3 de y (3 vha's) e 3 rótulos (3 vha's).\n\n#Por fim, foi definido um limite para o eixo Y de 50-120. Caso contrário, o gráfico define como valor máximo o maior valor de Y plotado (104 nesse caso), e a terceira coluna ficaria tocando o teto do gráfico."
  },
  {
    "objectID": "ggplot.html#color",
    "href": "ggplot.html#color",
    "title": "Visualização de Dados Florestais no R",
    "section": "Color",
    "text": "Color\nTalvez a escala mais frequentemente utilizada, a escala de cores é utilizada com o grupo de funções scale_color_, e pode receber variáveis numéricas ou categóricas.\n\ng.base &lt;- ggplot(dados, aes(d,h)) + \n  labs(x = \"DAP (cm)\", y = \"H (m)\",caption = \"Fonte: O autor.\")\n\n\nscale_color_brewer()\nA primeira função apresentada é a scale_color_brewer(). As funções terminadas em brewer usam paletas de cores pré-definidas, e isso é extremamente útil para escolher de forma rápida as cores das classes. Existem paletas específicas para mostrar realces entre classes, escalas sequenciais, escalas para dados qualitativos, etc. É possível conferir cada paleta de cores no site colorbrewer.org.\nNote que para utilizar as funções _brewer(), a variável mapeada precisa ser categórica. Caso seja declarada uma variável numérica, ela precisa ser convertida em fator para poder ser utilizada; vide o exemplo com npragas abaixo.\n\ng.base + geom_point(aes(color = projeto))\n\n\n\n\n\n\n\n#Note que, ao utilizar uma variável para compor as cores do gráfico, uma escala de cores é automaticamente criada\n\n#Utilizando scale_color_brewer()\ng.base + geom_point(aes(color = projeto)) + \n  labs(subtitle = \"scale_color_brewer()\") + \n  \n  scale_color_brewer(palette = \"Set1\") #Tente também \"Dark2\", \"Spectral\" e \"Paired\".\n\n\n\n\n\n\n\n#\"palette\" define a paleta de cores utilizada.\n\nOutro exemplo com número de ataques de pragas (npragas). npragas é uma variável numérica, e precisa ser convertida para categorias usando a função factor().\n\ng.base + geom_point(aes(color = factor(npragas))) + \n  labs(subtitle = \"scale_color_brewer() - npragas\") + \n  \n  scale_color_brewer(palette = \"OrRd\")\n\n\n\n\n\n\n\n#Perceba que o nome da legenda é, por padrão, a variável mapeada. Dificilmente uma variável estará escrita corretamente no banco de dados (e.g. \"projeto\" com p minúsculo, \"npragas\", \"classe\" com c minúsculo, etc.). O nome da escala é alterado com o argumento \"name\".\n\n#____________________________________________________\ng.base + geom_point(aes(color = factor(npragas))) + \n  labs(subtitle = \"Alterando o nome da escala\") + \n  \n  scale_color_brewer(palette = \"OrRd\", name = \"Ataque de Pragas (N)\")\n\n\n\n\n\n\n\n\n\n\nscale_color_gradient()\n\ng.base1 &lt;- g.base + geom_point(aes(color = vha))\n  \n g1 &lt;-  g.base1 + labs(subtitle = \"g1\") +\n   scale_color_gradient(low = \"yellow\", high = \"blue\", name = \"Volume (m³/ha)\") \n \n g2 &lt;- g.base1 + labs(subtitle = \"g2\") +\n   scale_color_gradient2(low = \"blue\",mid = \"orange\", high = \"red\",midpoint = 200) \n  \n g3 &lt;- g.base1 + labs(subtitle = \"g3\") +\n   scale_color_gradientn(colours = c(\"blue\",\"green\",\"yellow\",\"orange\",\"red\"), name = \"Volume (m³/ha)\")\n \n#install.packages(\"gridExtra\")\n#library(gridExtra)\n\n grid.arrange(g1,g2,g3, ncol = 2)\n\n\n\n\n\n\n\n#_gradient() cria uma escala gradiente com base na cor inferior e superior informada\n\n#_gradient2() cria uma escala gradiente divergente, especificando uma cor inferior, uma cor no meio da amplitude, e uma cor superior. É também preciso especificar o ponto médio da escala, caso contrário, é definido zero como padrão.\n\n#_gradientn() cria uma escala gradiente com base nas n cores informadas.\n\n\n\nscale_color_manual()\nEm últimos casos, é possível informar manualmente as cores desejadas, com o uso das funções _manual()\n\ng.base + geom_point(aes(color = classe)) + \n  labs(subtitle = \"Escala de cores manual\") + \n  \n  scale_color_manual(name = \"Classe de Sítio\", \n                     values = c(\"#b22222\",\"steelblue\",\"darkgreen\"),\n                     labels = c(\"Classe 1\", \"ClAsse 2\", \"ClAsse 3\"))\n\n\n\n\n\n\n\n# O argumento values define as cores utilizadas, note que é possível também informar o valor hexadecimal das cores, caso desejado. O argumento labels define os rótulos que serão apresentados na escala. Perceba também que o número de cores e rótulos informados deve ser o mesmo número de categorias da variável utilizada. Nesse caso, existem três classes de sítio.\n\n#Além disso, É preciso ficar atento à ordem em que a escala é disposta, que segue a ordem dos níveis da variável categórica. Por exemplo: caso a ordem de apresentação das classes fosse Classe II, Classe I, Classe III; o argumento labels deve ser informado com essa sequência em mente, caso contrário, se estará atribuindo o rótulo \"ClAsSe 1\" para a categoria \"Classe II\", por exemplo. Fica a recomendação de, sempre que uma situação similar surgir, plotar o gráfico primeiramente sem alterar os rótulos da escala, e verificar a ordem em que as categorias são dispostas.\n\n\n\nTudo manual\nMas, e se não existir uma variável para informar a estética dentro de aes(), como criar a legenda?\nIsso é comum quando se está trabalhando com diferentes bancos de dados, por exemplo, um data frame para cada projeto.\n\nunique(dados$projeto)\n\n[1] \"Campo Alto\" \"Campina\"    \"Lageadinho\" \"Perdidinha\"\n\ndf.p1 &lt;- subset(dados, projeto == \"Campina\")\ndf.p2 &lt;- subset(dados, projeto == \"Campo Alto\")\ndf.p3 &lt;- subset(dados, projeto == \"Lageadinho\")\ndf.p4 &lt;- subset(dados, projeto == \"Perdidinha\")\n#________________________________________________________\nggplot() + #Os ponto vem de data frames diferentes, então não há porque inserir aqui\n  \n  geom_point(data = df.p1, aes(d,v), color = \"red\") + \n  geom_point(data = df.p2, aes(d,v), color = \"blue\") + \n  geom_point(data = df.p3, aes(d,v), color = \"green\") +\n  geom_point(data = df.p4, aes(d,v), color = \"orange\")\n\n\n\n\n\n\n\n\nComo não foi utilizada nenhuma variável para mapear as cores, o ggplot não cria uma escala. É preciso jogar o argumento color para dentro de aes(), para poder ser mapeado, e como variável é possível escrever algum nome, qualquer coisa, geralmente algo que remeta aos dados representados, para facilitar. Esses falsos nomes “mapeados” serão depois conectados com a função scale_color_manual().\n\nggplot() + \n  geom_point(data=df.p1, aes(d,v, color = \"p1\")) +\n  geom_point(data=df.p2, aes(d,v, color = \"p2\")) + \n  geom_point(data=df.p3, aes(d,v, color = \"p3\")) + \n  geom_point(data=df.p4, aes(d,v, color = \"p4\")) + \n  \n  scale_color_manual(name = \"Projeto\", \n                     values = c(\"p1\" = \"red\", \n                                \"p2\" = \"blue\",\n                                \"p3\" = \"green\",\n                                \"p4\" = \"orange\"),\n                     \n                     labels = c(\"p3\" = \"Lageadinho\",\n                                \"p1\" = \"Campina\",\n                                \"p4\" = \"Perdidinha\",\n                                \"p2\" = \"Campo Alto\"))\n\n\n\n\n\n\n\n# Perceba que em geom_point() foi utilizado um nome qualquer apenas para mapear a cor, e consequentemente gerar uma escala para isso. Já em scale_color_manual(), cada nome vinculado com uma cor específica no argumento values, bem como cada nome foi vinculado com um rótulo específico no argumento labels. Note também que, uma vez que cada nome é vinculado a um rótulo específico, não há necessidade de informar os campos em alguma ordem específica.\n\n#Caso o nome do projeto fosse escrito diretamente nos geom_point, o argumento labels poderia ser omitido.\n\n\n\nQuando há várias geometrias\n\nggplot(dados, aes(d,v)) + \n  labs(x = \"DAP (cm)\", y = \"Volume (m³)\", subtitle = \"Legenda ruim\") +\n  \n  geom_point(aes(color = \"Observados\")) +\n  \n  stat_smooth(aes(color = \"Ajuste\"), se = FALSE) +\n  \n  scale_color_manual(name = NULL, values = c(\"Observados\" = \"steelblue\",\n                                             \"Ajuste\" = \"darkblue\"))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nPercebe-se que o ponto e a linha são repetidos na legenda. Isso ocorre porque o argumento color foi utilizado em duas geometrias diferentes (geom_point e stat_smooth), e nesse caso o ggplot irá criar a escala de cores evidenciando que há duas geometrias na sua escala. Para contornar isso, é preciso sobrepor a estética de cor, e informar manualmente como serão montados os ícones da legenha. Isso é feito com o comando guides()\n\nggplot(dados, aes(d,v)) + \n  labs(x = \"DAP (cm)\", y = \"Volume (m³)\", subtitle = \"Legenda boa\") + \n  \n  geom_point(aes(color = \"Observados\")) +\n  \n  stat_smooth(aes(color = \"Ajuste\"), se = FALSE) +\n  \n  scale_color_manual(name = NULL, values = c(\"Observados\" = \"steelblue\",\n                                             \"Ajuste\" = \"darkblue\")) +\n\n guides(color = guide_legend(override.aes = list(shape = c(16,NA),\n                                                  linetype = c(NA,1))))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n#\"color = \" indica que a mudança será na escala de cores;\n#\"override.aes\" burla o formato padrão da estética do gráfico e permite alterar o que quisermos, as mudanças são informadas por uma lista.\n#\"shape = c(NA,16)\" indica as formas dos pontos que irão compor os ícones. Como nesse caso são dois ícones, então dois valores serão informados em sequência. NA informa que não será inserido nenhum ponto na primeira posição. 16 significa que será colocado um ponto com o formato número 16 (é o padrão do geom_point) na segunda posição.\n#\"linetype = c(1,NA)\" indica que tipo de linha será inserido em cada ícone. Nesse caso, será inserida uma linha contínua (tipo 1) na primeira posição, e nenhuma linha (NA) no segundo ícone. \n\n#Boom."
  },
  {
    "objectID": "ggplot.html#fill-shape-size-linewidth-linetype",
    "href": "ggplot.html#fill-shape-size-linewidth-linetype",
    "title": "Visualização de Dados Florestais no R",
    "section": "Fill, Shape, Size, Linewidth, Linetype…",
    "text": "Fill, Shape, Size, Linewidth, Linetype…\nPara nossa alegria, quase todas as demais escalas (scale_fill_, scale_size_, scale_shape_, scale_linetype_…) funcionam de maneira igual ou semelhante à apresentada na escala de cores"
  },
  {
    "objectID": "ggplot.html#x-e-y",
    "href": "ggplot.html#x-e-y",
    "title": "Visualização de Dados Florestais no R",
    "section": "X e Y",
    "text": "X e Y\nComo mencionado anteriormente, as variáveis mapeadas em X e Y também recebem uma escala, e são apresentadas como os eixos X e Y, porém elas também podem ser manipuladas, de maneira similar às demais. As funções são escritas com scale_x_ e scale_y_.\nDentre as opções de escala, estão _continuous(), _discrete(), _log10(), _reverse(), _date(), _sqrt() e _time().\nComo se pode perceber, é possível organizar os eixos de acordo com o tipo de variável inserida, como datas ou tempo, e ainda fazer transformações dos dados, como raiz quadrada ou logaritmo. Também é possível inverter a escala com _reverse().\nUma das principais razões em alterar a escala dos eixos é para modificar a numeração de cada eixo, adicionando mais ou menos marcas, com números mais ou menos espaçados. Além disso, é possível adicionar pequenos símbolos junto aos números em escalas contínuas, como porcentagem ou expoentes.\nPor praticidade, as operações serão todas feitas no eixo X, mas alterações no eixo Y são da mesma forma.\n\ng.base &lt;- ggplot(dados, aes(d,v)) + \n  labs(x = \"DAP(cm)\", y = \"Volume (m³)\") +\n  geom_point()\n\ng.base\n\n\n\n\n\n\n\n\n\nExemplos\n\n#Define que as quebras serão uma sequência de 0 a 30, de 2 e 2\ng.base + scale_x_continuous(breaks = seq(0,30,2)) \n\n\n\n\n\n\n\n#As quebras são definidas no argumento breaks.\n\n#Define que as quebras irão de 0 a 10, de 1 em 1\ng.base + scale_x_continuous(breaks = seq(0,10,1))\n\n\n\n\n\n\n\n#Observe que informar uma amplitude de valores menor que a real amplitude dos dados não delimita o início e fim do eixo.\n\n#Adiciona um símbolo nos números\ng.base + scale_x_continuous(labels = function(numero) paste0(numero,\"%\"))\n\n\n\n\n\n\n\n#Os rótulos dos eixos são definidos pelo argumento labels. Note que o argumento recebe uma função que, para cada número do eixo, pegue esse numero e cole-o junto com o símbolo \"%\".\n\n#Juntando breaks e labels\ng.base + scale_x_continuous(breaks = seq(0,30,2), labels = function(x) paste0(x,\"%\"))\n\n\n\n\n\n\n\n#Invertendo o eixo\ng.base + scale_x_reverse()\n\n\n\n\n\n\n\n#Os outros comandos permanecem disponíveis\ng.base + scale_x_reverse(breaks = seq(0,30,2), labels = function(x) paste0(x,\"%\"))"
  },
  {
    "objectID": "ggplot.html#a-família-element_",
    "href": "ggplot.html#a-família-element_",
    "title": "Visualização de Dados Florestais no R",
    "section": "A família element_",
    "text": "A família element_\nPara fazer alguma mudança nos títulos dos eixos, por exemplo, o argumento é theme(axis.title = ). Assim, será realizada uma mudança dentro dos títulos dos eixos. Note que essas opções também podem ser feitas para algum eixo específico (via axis.title.x e axis.title.y).\nJá para alterar as linhas de grade do fundo do gráfico, o argumento é panel.grid,com suas variações para eixo e para maiores ou menores.\nComo terceiro exemplo, é possível alterar a cor do fundo do gráfico, pelo argumento panel.background. Vamos ver esses três exemplos no gráfico abaixo.\n\nggplot(dados, aes(d,v)) + \n  geom_point() + \n  labs(x = \"DAP (cm)\", y = \"Volume(m³)\") + \n  \n  theme(axis.title = element_text(face = \"bold\"),\n        panel.grid = element_line(color = \"blue\"),\n        panel.background = element_rect(fill = \"orange\"))\n\n\n\n\n\n\n\n\nNote que para cada alteração há uma função element_ diferente. A decisão de qual usar depende do tipo de alteração.\n\nelement_rect(): usada para alterar elementos que envolvem uma área, que possam ser preenchidos (fill);\nelement_line(): usada para alterar linhas em geral;\nelement_text(): usada para alterar caracteres de texto;\nelement_blank(): usada para remover o elemento do gráfico.\n\nPerceba que no exemplo acima, a mudança dos títulos dos eixos recebe element_text; as linhas de grade são alteradas com element_line; e o fundo do gráfico recebe element_rect. Cada função da família element_ possui dentro de si argumentos referentes à seu tipo de alteração, ou seja, não há a opção ‘fill’ dentro de element_line, por exemplo, pois linhas não possuem preenchimento.\n\ng.base &lt;- ggplot(dados, aes(d,v)) + geom_point() + \n  labs(x = \"DAP (cm)\", y = \"Volume (m³)\")\n\n\nExemplos\n\n# Removendo linhas de grade - element_blank()\ng.base + theme(panel.grid = element_blank())\n\n\n\n\n\n\n\n# Mudando o tamanho dos eixos\ng.base + theme(axis.text = element_text(size = 12))\n\n\n\n\n\n\n\n# alterando a caixa do gráfico\ng.base + theme(panel.border = element_blank(),\n               axis.line = element_line(linewidth = 1))\n\n\n\n\n\n\n\n# Outros exemplos\ng.base + theme(panel.border = element_blank(),\n               axis.line = element_line(linewidth = 1),\n               panel.grid = element_blank(),\n               axis.text = element_text(color = \"black\"),\n               axis.title = element_text(face = \"bold\"))\n\n\n\n\n\n\n\ng.base + labs(title = \"Relação H-d\")\n\n\n\n\n\n\n\ng.base + labs(title = \"Relação H-d\") + \n  theme(plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\ng.base + labs(title = \"Relação H-d\") + \n  theme(axis.title.x = element_text(hjust = 0.1),\n        axis.title.y = element_text(hjust = 0.9, face = \"italic\"))\n\n\n\n\n\n\n\n#Note que hjust realiza um deslocamento horizontal relativo ao próprio eixo."
  },
  {
    "objectID": "ggplot.html#temas-prontos",
    "href": "ggplot.html#temas-prontos",
    "title": "Visualização de Dados Florestais no R",
    "section": "Temas prontos",
    "text": "Temas prontos\nHá também uma porção de temas prontos. Para utilizá-los, basta adicionar alguma função theme_ e selecionar a função desejada. Alguns exemplos são theme_classic(), theme_bw(), theme_minimal(), theme_grey(), theme_dark().\nMais temas podem ser obtidos no pacote ggthemes\nIMPORTANTE: Caso queira utilizar um tema pronto, e ainda assim realizar alguns ajustes nele, apenas tenha o cuidado de adicionar o tema pronto (theme_) antes da função de modificação de temas (theme()). Caso contrário, o tema pronto irá sobrepor as modificações.\n\ng.base + theme_get()\n\n\n\n\n\n\n\ng.base + theme_gray()\n\n\n\n\n\n\n\ng.base + theme_dark()\n\n\n\n\n\n\n\ng.base + theme_minimal()\n\n\n\n\n\n\n\ng.base + theme_light()\n\n\n\n\n\n\n\ng.base + theme_linedraw()\n\n\n\n\n\n\n\ng.base + theme_classic()\n\n\n\n\n\n\n\ng.base + theme_bw() #é o utilizado ao longo desse script"
  },
  {
    "objectID": "ggplot.html#mudando-a-legenda",
    "href": "ggplot.html#mudando-a-legenda",
    "title": "Visualização de Dados Florestais no R",
    "section": "Mudando a legenda",
    "text": "Mudando a legenda\nNo tema, é possível fazer algumas alterações na legenda. As principais são definir a posição da legenda ou ocultá-la.\n\ng.base &lt;- g.base + geom_point(aes(color = classe))\n\n#____________________________________________________________\n# Inserindo a legenda na base do gráfico\ng.base + theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n#o padrão é right, mas é possível informar \"bottom\", \"left\", e \"top\"\n\n# Inserindo dentro do gráfico\ng.base + theme(legend.position.inside = c(0.05,0.98),\n               legend.justification = c(0,1),\n               legend.background = element_rect(fill = \"grey\"))\n\n\n\n\n\n\n\n#Para inserir dentro do gráfico, em vez de um dos comandos do exemplo acima, são informados um par de coordenadas (x,y) em legend.position.inside, que varia de 0% até 100% (0 a 1) do respectivo eixo. O comando legend.justification representa o ponto de ancoragem da legenda; no exemplo, a ancoragem está no canto esquerdo superior (c(1,1) é superior direito, c(0,0), é inferior esquerdo, e c(1,0) é inferior direito). Isso significa que o ponto de ancoragem será colocado exatamente na coordenada informada. O comando legend.background foi adicionado para realçar os pontos de ancoragem.\n\n# Alterando título da legenda\ng.base + theme(legend.title = element_text(face = \"bold.italic\", size = 15, color = \"red\"))\n\n\n\n\n\n\n\n# Espaçamento dos símbolos\ng.base + theme(legend.key.height = unit(0,\"mm\"))\n\n\n\n\n\n\n\ng.base + theme(legend.key.height = unit(0,\"mm\"),\n               legend.key.width = unit(2,\"cm\"))"
  },
  {
    "objectID": "ggplot.html#análise-discriminante",
    "href": "ggplot.html#análise-discriminante",
    "title": "Visualização de Dados Florestais no R",
    "section": "Análise discriminante",
    "text": "Análise discriminante\n\n# Plotando os dois primeiros autovetores\n#library(MASS)\n#library(ggalt)\n\nad &lt;- lda(classe ~ d + hdom + gha + npragas + idade, data = dados)\n\npred.ad &lt;- as.data.frame(predict(ad)[[\"x\"]])\npred.ad$class &lt;- predict(ad)$class\n\npred.ad.I &lt;- subset(pred.ad, class == \"Classe I\")\npred.ad.II &lt;- subset(pred.ad, class == \"Classe II\")\npred.ad.III &lt;- subset(pred.ad, class == \"Classe III\")\n#geom_encircle() é aplicado sobre todo o banco de dados, por isso foi preciso separar cada grupo antes, caso contrário o contorno iria sobre todos os pontos.\n\n#__________________________________________________________\nggplot(pred.ad) + \n  geom_point(aes(x = LD1, y = LD2, shape = class, color = class)) +\n  geom_encircle(data = pred.ad.I, aes(LD1,LD2, fill = class), color = NA,alpha = 0.1, expand = 0.015) + \n  geom_encircle(data = pred.ad.II, aes(LD1,LD2, fill = class), color = NA, alpha = 0.1, expand = 0.015) +\n  geom_encircle(data = pred.ad.III, aes(LD1,LD2, fill = class), color = NA, alpha = 0.1, expand = 0.015) + \n  \n  labs(subtitle = \"Discriminação dos Grupos com base nos dois primeiros autovetores\") +\n  \n  scale_color_brewer(palette = \"Dark2\", name = \"Classe de Sítio\") + \n  scale_fill_brewer(palette = \"Dark2\", guide = 'none') +\n  scale_shape(guide = 'none') + \n  guides(color = guide_legend(override.aes = list(shape = c(16,17,15),\n                                                  linetype = c(NA,NA,NA)))) +\n  theme(panel.grid = element_blank())"
  },
  {
    "objectID": "ggplot.html#regressão",
    "href": "ggplot.html#regressão",
    "title": "Visualização de Dados Florestais no R",
    "section": "Regressão",
    "text": "Regressão\n\n#Ajuste não linear\n#___________________________________________________\nfit &lt;-nls(v ~ b0*d^b1, \n          data = dados, \n          start = list(b0 = 1, b1 = 3))\n\ncoef(fit)\n\n          b0           b1 \n0.0001662425 2.5072366676 \n\nfunc.fit &lt;- function(x) {coef(fit)[1]*x^coef(fit)[2]}\n#___________________________________________________\n\n\n#Ajuste por regressão quantílica\n#__________________________________________________\n#install.packages(\"quantreg\")\nlibrary(quantreg)\n\nCarregando pacotes exigidos: SparseM\n\nq.fit &lt;- nlrq(v ~ b0*d^b1, \n              data = dados, \n              start = list(b0 = 1, b1 = 3 ),\n              tau = 0.95)\n\ncoef(q.fit)\n\n          b0           b1 \n0.0002967183 2.3500387643 \n\nfunc.q.fit &lt;- function(x) {coef(q.fit)[1]*x^coef(q.fit)[2]} \n#____________________________________________________\n\n\n#Gráfico\n#___________________________________________________\n\nggplot(dados, aes(x = d, y = v)) + \n  labs(x=\"DAP (cm)\",\n       y=\"Volume (m³)\",\n       subtitle=\"Regressão Quantílica\") +\n  \n  geom_point(aes(color = \"Observados\"), \n             alpha = 0.7,\n             size = 2) +\n  \n  stat_function(fun = func.fit,\n                aes(color = \"Média\"),\n                linewidth = 1) + \n  \n  stat_function(fun = func.q.fit,\n                aes(color = \"95%\"),\n                linewidth = 1) + \n  \n  scale_color_manual(name = NULL,\n                     values = c(\"Observados\" = \"black\",\n                                \"Média\" = \"#1b9e77\",\n                                \"95%\" = \"#d95f02\")) +\n  \n  guides(color = guide_legend(override.aes = list(shape = c(16, NA,NA),\n                                                  linetype = c(NA, 1,1)))) + \n  \n  theme_classic() + \n  \n  theme(legend.justification = c(1,0),\n        legend.position.inside = c(0.98,0.02),\n        plot.subtitle = element_text(face = \"bold\",\n                                     hjust = 0.5))"
  },
  {
    "objectID": "ggplot.html#resíduos",
    "href": "ggplot.html#resíduos",
    "title": "Visualização de Dados Florestais no R",
    "section": "Resíduos",
    "text": "Resíduos\n\n#Obtendo resíduos ordinários\nres &lt;- residuals(fit)\n\n#Obtendo volumes estimados\nv.est &lt;- fitted(fit)\n\n#Criando Gráfico\n#________________________________________\nggplot() + theme_classic() +\n      geom_point(aes(x = v.est, y = res), alpha = 0.7) + \n      labs(x = \"Volume Estimado (m³)\", y = \"Resíduos (m³)\") + \n      geom_hline(yintercept = 0, color = \"red\", linewidth = 1) + \n      coord_cartesian(ylim = c(-0.045, 0.045))"
  },
  {
    "objectID": "colheita.html",
    "href": "colheita.html",
    "title": "Colheita, Transporte e Logística Florestal",
    "section": "",
    "text": "Plano de Ensino\nGuia de Estudo\n\nConteúdo Programático\n\n\nData\nConteúdo\nMateriais\n\n\n\n\n03/02/2025\n\n1 Apresentação do plano de ensino da disciplina, guia de estudos e introdução à disciplina\n2 Introdução à colheita, exploração e transporte florestal\n\n\nAula 1\nAula 2 | Material complementar I\n\n\n\n10/02/2025\n\nCorte florestal\n\n\n\n\n17/02/2025\nExtração florestal\n\n\n\n24/02/2025\nCarregamento e descarregamento florestal\n\n\n\n03/03/2025\nCarnaval - Sem Aula\n\n\n\n10/03/2025\nSistemas de colheita florestal\n\n\n\n17/03/2025\nVerificação de aprendizagem I\n\n\n\n24/03/2025\nLogística e transporte florestal\n\n\n\n31/03/2025\nPlanejamento das operações de colheita, exploração e transporte florestal\n\n\n\n07/04/2025\n\nControle de produção e custos na colheita e exploração florestal\nSorteio dos temas do trabalho\n\n\n\n\n14/04/2025\n\nSegurança do trabalho e ergonomia aplicada à colheita e exploração florestal\nPossíveis dúvidas referentes ao trabalho\n\n\n\n\n21/04/2025\nFeriado de Tiradentes - Sem Aula\n\n\n\n28/04/2025\nRevisão para verificação de aprendizagem II\n\n\n\n05/05/2025\nVerificação de aprendizagem II\n\n\n\n12/05/2025\nApresentação dos trabalhos\n\n\n\n19/05/2025\nExame final"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dendrometria.html",
    "href": "dendrometria.html",
    "title": "Dendrometria",
    "section": "",
    "text": "Plano de Ensino\nGuia de Estudo\n\nConteúdo Programático\n\n\n\n\n\n\n\nData\nConteúdo\nMateriais\n\n\n\n\n04/02/2025\nApresentação do plano de ensino da disciplina, princípios de mensuração, diâmetro e área basal.\n\n\n\n11/02/2025\nAltura das árvores (Princípios de medição).\n\n\n\n18/02/2025\nAula de campo (Fazenda experimental).\n\n\n\n25/02/2025\nAltura das árvores (Relação altura-diâmetro).\n\n\n\n04/03/2025\nCarnaval - Sem aula.\n\n\n\n11/03/2025\nMédias dendrométricas.\n\n\n\n18/03/2025\nVerificação de aprendizagem I\n\n\n\n25/03/2025\nVolume das árvores (sólidos de revolução e cubagem rigorosa).\n\n\n\n01/04/2025\n\nVolume das árvores (sólidos de revolução e cubagem rigorosa).\nVolume Comercial.\n\n\n\n\n08/04/2025\nVolume das árvores (estimativas por regressão).\n\n\n\n15/04/2025\nVerificação de aprendizagem II\n\n\n\n22/04/2025\n\nQuantificação da biomassa florestal.\nCrescimento de árvores.\n\n\n\n\n29/04/2025\nCrescimento de árvors (noções de crescimento e produção).\n\n\n\n06/05/2025\nRelascopia\n\n\n\n13/05/2025\nVerificação de aprendizagem III\n\n\n\n20/05/2025\nExame Final"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "Olá. Esse é um trabalho em construção, fruto do que tenho aprendido sobre R e estatística ao longo do tempo. Sinta-se livre para usar e adaptar qualquer coisa que achar interessante, só peço que cite o site caso o faça.\nSe encontrar um erro ou ter alguma dúvida não hesite em entrar em contato através da minha página no github."
  },
  {
    "objectID": "MQO.html",
    "href": "MQO.html",
    "title": "Mínimos Quadrados Ordinários",
    "section": "",
    "text": "library(ggplot2)\nlibrary(gganimate)\nlibrary(magrittr)\nlibrary(dplyr)\nlibrary(kableExtra)\nUtilizaremos o banco de dados trees. Esse banco de dados contém informações sobre o diâmetro em polegadas, altura em pés e volume em pés³ de 31 árvores black cherry.\nAlém disso, os gráficos serão gerados utilizando o pacote ggplot2, com comentários pertinentes sobre as funções utilizadas. Os comandos do pacote ggplot2 são inseridos em camadas, normalmente iniciando por uma função que indica o banco de dados utilizado, e posteriormente as demais funções. As variáveis que serão utilizadas para criar os gráficos devem sempre estar “mapeadas” para serem encontradas, e a maneira de fazer isso é inserindo-as dentro do argumento aes(). No exemplo abaixo, o primeiro nível de comando especifica o banco de dados utilizado. O segundo indica o tipo de gráfico a ser criado e mapeia as variáveis de interesse. O terceiro comando introduz os títulos dos eixos, do gráfico, etc. E o quarto comando aplica um tema pronto ao gráfico. Para mais informações sobre pacote ggplot, acesse esse breve tutorial.\ndata(\"trees\")\n\n# Transforma as variáveis para unidades comumente utilizadas\nd &lt;- trees$Girth/2.54     # polegadas para centímetros\nht &lt;- trees$Height/3.281  # pés para metros\nv &lt;- trees$Volume/34.286  # pés cúbicos para metros cúbicos\nd2h &lt;- d^2*ht             \n\n# 'd' é um vetor de diâmetros, e possui 31 elementos. Ou length(d)\nd\n\n [1] 3.267717 3.385827 3.464567 4.133858 4.212598 4.251969 4.330709 4.330709\n [9] 4.370079 4.409449 4.448819 4.488189 4.488189 4.606299 4.724409 5.078740\n[17] 5.078740 5.236220 5.393701 5.433071 5.511811 5.590551 5.708661 6.299213\n[25] 6.417323 6.811024 6.889764 7.047244 7.086614 7.086614 8.110236\n\nlength(d)\n\n[1] 31\n\n# O mesmo ocorre com ht, v e d2h.\n\n# Agrupa tudo em um único data frame\ndados &lt;- data.frame(d,ht,v,d2h)\n\ng.base &lt;- ggplot(data = dados, \n                 aes(x = d2h, y = v)) +     #Introduz o dataframe utilizado\n  \n  geom_point() + #geom_point() cria gráfico de pontos\n  \n  labs(x = \"d2h\",          #Adiciona Títulos dos eixos e do gráfico\n       y = \"Volume (m³)\",\n       title = \"Volume em função de d2h\") + \n  \n  theme_bw()                #Adiciona o tema Black and White\n\n\nplot(g.base)\nA figura acima demonstra a relação entre volume e \\(d^2h\\). Essa relação é conhecida no meio florestal através do modelo de Spurr: \\(v = \\beta_0 + \\beta_1.d^2h\\), e evidencia a relação linear entre as duas variáveis.\nPara encontrar os parâmetros do modelo, basta utilizar a função lm().\nspurr &lt;- lm(v ~ d2h, data = dados)\n\nsummary(spurr)\n\n\nCall:\nlm(formula = v ~ d2h, data = dados)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.13473 -0.03209 -0.00483  0.05090  0.12243 \n\nCoefficients:\n               Estimate  Std. Error t value            Pr(&gt;|t|)    \n(Intercept) -0.00868224  0.02810346  -0.309                0.76    \nd2h          0.00131156  0.00003673  35.711 &lt;0.0000000000000002 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.07271 on 29 degrees of freedom\nMultiple R-squared:  0.9778,    Adjusted R-squared:  0.977 \nF-statistic:  1275 on 1 and 29 DF,  p-value: &lt; 0.00000000000000022\n\ncoef(spurr)\n\n (Intercept)          d2h \n-0.008682245  0.001311559 \n\ng.base + labs(title = \"Modelo de Spurr Ajustado\") +\n  geom_abline(intercept = coef(spurr)[1],  #Coeficiente linear  (b0)\n              slope = coef(spurr)[2],      #Coeficiente angular (b1)\n              color = \"steelblue\")\nOs valores de \\(\\beta_0\\) e \\(\\beta_1\\) encontrados foram de -0.0087 e 0.0013, respectivamente.\nAgora vamos tentar chegar nos mesmos parâmetros realizando o método dos mínimos quadrados ordinários passo a passo."
  },
  {
    "objectID": "MQO.html#mínimos-quadrados-ordinários",
    "href": "MQO.html#mínimos-quadrados-ordinários",
    "title": "Mínimos Quadrados Ordinários",
    "section": "Mínimos Quadrados Ordinários",
    "text": "Mínimos Quadrados Ordinários\nO método dos mínimos quadrados ordinários é o principal método de estimativa dos parâmetros para regressões lineares, e tem como objetivo encontrar os parâmetros do modelo que resultem na menor soma de quadrados dos resíduos. Sua utilização depende de pressupostos. São eles:\n\n1. Resíduos com média 0 e distribuição normal;\n2. Variância do erro constante;\n3. Independência dos resíduos.\n\nA formulação tradicional do modelo linear simples é exemplificada abaixo,\n\\[\ny = \\beta_0 + \\beta_1x + \\epsilon\n\\]\nOnde \\(\\beta_0\\) é o parâmetro linear, também chamado de intercepto ou constante, pois não depende de \\(x\\); \\(\\beta_1\\) é o parâmetro angular ou coeficiente da variável \\(x\\); \\(\\epsilon\\) é o erro, e representa a variação de \\(y\\) que não é explicada pelo modelo. Outra formulação encontrada na literatura é \\(y = \\alpha + \\beta x + \\epsilon\\).\nOs valores estimados ou preditos da variável \\(y\\) são denotados por \\(\\hat{y}\\),\n\\[\n\\hat{y} = \\hat{\\beta_0} + \\hat{\\beta_1}x\n\\]\nOs parâmetros verdadeiros \\(\\beta_i\\) do modelo são desconhecidos, e em vez disso se utiliza \\(\\hat{\\beta_0}\\) e \\(\\hat{\\beta_1}\\) para definir os parâmetros estimados pela regressão.\nO erro \\(\\epsilon\\) nada mais é que a diferença entre o valor real observado \\(y\\), e o valor estimado ou predito \\(\\hat{y}\\).\n\\[\n\\epsilon_i = y_i - \\hat{y_i}\n\\]\nComo citado anteriormente, o objetivo do método é encontrar os parâmetros que resultem na menor soma de quadrados de resíduos (\\(S\\)). Como os resíduos devem possuir média zero e distribuição normal, alguns resíduos são positivos e outros negativos. Nessa situação, a simples soma teria efeito de ‘compensação’ entre valores positivos e negativos, e o resultado final não representaria de forma apropriada o erro do modelo (o somatório seria próximo de zero). Ao elevar cada erro \\(\\epsilon\\) ao quadrado, temos uma melhor estimativa do erro a ser minimizado.\n\nO leitor mais rigoroso pode perceber que essa não é uma explicação suficiente para a dedução do método. Entretanto, esse pequeno texto busca atender também aqueles que estão iniciando seus estudos em estatística. Uma abordagem mais teórica pode ser obtida partindo da função de verossimilhança do modelo de regressão.\n\n\\[\nS = \\sum_{i=1}^{n} \\epsilon_i^2\n\\]\nCom a substituição de alguns termos com as equações apresentadas acima, temos que\n\\[\nS = \\sum_{i=1}^{n} (y_i - \\hat{y_i})^2\n\\]\n\\[\nS = \\sum_{i=1}^{n} (y_i - [\\hat{\\beta_0} + \\hat{\\beta_1}x_i])^2\n\\]\n\\[\nS = \\sum_{i=1}^{n} (y_i - \\hat{\\beta_0} - \\hat{\\beta_1}x_i)^2\n\\]\nAgora, se atribuíssemos algum valor qualquer para os parâmetros no modelo acima e calculássemos o somatório, isso resultaria em um valor \\(S\\) de Soma de Quadrados de Resíduos. Conforme os valores dos parâmetros mudam, então também a Soma de Quadrados de Resíduos (\\(S\\)) irá mudar.\n\n#Cria uma função S que recebe os parâmetros x,y,a,b\nS &lt;- function(x,y,b0,b1) {sum((y-b0-b1*x)^2)}\n\n#Essa função criada recebe 4 argumentos: um vetor x, um vetor y, um valor de b0 e um valor de b1. Como x e y são dois vetores e b0 e b1 são dois valores, o que a função fará é realizar a operação y - b0 - b1*x para os primeiros valores de x e y e elevar o resultado ao quadrado. A seguir, realiza a mesma operação para os segundos valores e eleva o resultado ao quadrado. Por fim, é requisitado por meio da função sum() que faça o somatório de todos esses resultados. Por fim, isso resultará em um único valor que é a soma do quadrado dos resíduos para aquele par de coeficientes b0 e b1 informados.\n\n#Cria um vetor de possíveis valores de b0 e b1\nb_0 &lt;- seq(from = -0.5, to = 0.5, by = 0.01)  #De -0.5 até 0.5, ao passo de 0.01\nb_1 &lt;- seq(from = -0.5, to = 0.5, by = 0.01)\n\n#Isso resulta em 101 valores diferentes de b0 e b1.\nlength(b_0) ; length(b_1)\n\n[1] 101\n\n\n[1] 101\n\n#Cria vetor que receberá o resultado de S para cada possível valor de b0 e b1. Naturalmente, deve ter o mesmo comprimento do número de possíveis valores dos coeficientes.\nS.est &lt;- vector(length = length(b_0))  #Vetor de comprimento igual ao vetor b0\n\n#Cria um loop para estimar cada valor de S baseado em cada valor de b0 e b1\nfor (i in 1:length(S.est)) {\n  \n  S.est[i] &lt;- S(x = dados$d2h,  \n                y = dados$v,\n                b0 = b_0[i],\n                b1 = b_1[i])\n}\n\n#O comando acima pega a função S() criada acima, joga os primeiros valores de b0 e b1 dos vetores, calcula o valor de S e o guarda na primeira posição do vetor S.est. A seguir, pega todos valores das segundas posições dos vetores, joga na função S() criada e resgata o valor resultante, salvando na segunda posição do vetor S.est. Esse processo é repetido de 1:length(S.est), ou seja, do primeiro até o último valor dos vetores.\n\n\n#Criando um data frame com as variáveis\ndf &lt;- data.frame(\"b0\" = b_0,\n                 \"b1\" = b_1,\n                 \"S\" = S.est)\n\ng.S &lt;- ggplot(data = df, aes(x = b0, y = S)) + \n  geom_line(aes(color = S.est), size = 1) +  # Cria uma reta conectando cada observação. Como são 101 pontos, o resultado terá a forma de uma parábola.\n  labs(x = expression(\"Parâmetro \"*beta[0]), y = \"S (m³)²\", subtitle = expression(\"Efeito de \"*beta[0]*\" na Soma de Quadrado dos Resíduos\")) + \n  scale_color_gradient(low = \"blue\", high = \"red\", name = \"S (m³)²\") + \n  geom_segment(aes(x=-0.2,xend=0.2, y = min(S), yend = min(S)), color = \"black\") +\n  theme_bw()\n\n\n\nplot(g.S)\n\n\n\n\n\n\n\n\nNa figura acima, percebe-se que quando \\(\\hat{\\beta_0}\\) é próximo de -0.5, a soma de quadrado dos resíduos é alta, assim como perto de 0.5. Entretanto, quando \\(\\hat{\\beta_0}\\) é próximo de 0, S atinge os menores valores. Se fizéssemos esse procedimento com \\(\\hat{\\beta_1}\\), esse mesmo comportamento seria observado. Em outras palavras, existe um determinado valor de \\(\\hat{\\beta_0}\\) e \\(\\hat{\\beta_1}\\) que resultam no valor mínimo de S. Para encontrar os valores exatos, podemos fazer uso do cálculo diferencial.\nAnalisando a figura, percebemos que o ponto que resulta no menor valor de S é um ponto de mínima, e se trassarmos uma reta tangente à curva nesse ponto, essa reta será perfeitamente horizontal.\nUma maneira adequada para encontrar pontos críticos em uma função é utilizando cálculo diferencial, sabendo que nos pontos onde a primeira derivada for igual a zero, então a tangente da função será perfeitamente horizontal, marcando assim um ponto de máxima ou mínima.\nPara encontrarmos os valores de \\(\\hat{\\beta_0}\\) e \\(\\hat{\\beta_1}\\) que minimizam S, precisamos derivar a função S em relação a esses parâmetros. Esse procedimento é chamado de derivada parcial (denotado por \\(\\partial\\)), e em linhas gerais tudo que não possuir relação com o parâmetro alvo é considerado como constante.\nPrimeiramente podemos abrir o polinômio da função \\(S\\).\n\\[\nS = \\sum_{i=1}^{n} (y_i - \\hat{\\beta_0} - \\hat{\\beta_1}x_i)^2\n\\]\n\\[\nS = \\sum_{i=1}^{n} (y_i^2 - y_i\\hat{\\beta_0} - y_i\\hat{\\beta_i}x_i-y_i\\hat{\\beta_0} + \\hat{\\beta_0}^2 + \\hat{\\beta_0}\\hat{\\beta_1}x_i - y_i\\hat{\\beta_1}x_i + \\hat{\\beta_0}\\hat{\\beta_1}x_i + \\hat{\\beta_1}^2x_i^2)\n\\]\n\\[\nS = \\sum_{i=1}^{n} (y_i^2 + \\hat{\\beta_0}^2 + \\hat{\\beta_1}^2x_i^2 -2y_i\\hat{\\beta_0} - 2y_i\\hat{\\beta_1}x_i + 2\\hat{\\beta_0}\\hat{\\beta_1}x_i)\n\\]\n\n\n\nDerivada parcial em relação à \\(\\hat{\\beta_0}\\)\nAs regras de derivação são as mesmas de qualquer outra diferenciação. A única diferença é que, agora, a variável de interesse é \\(\\hat{\\beta_0}\\), e tudo o mais é considerado constante.\n\\[\n\\frac{\\partial S}{\\partial \\hat{\\beta_0}} = \\sum_{i=1}^{n} (0 + \\hat{\\beta_0}^2 + 0 - 2y_i\\hat{\\beta_0} - 0 + 2\\hat{\\beta_0}\\hat{\\beta_1}x_i)\n\\]\n\\[\n\\frac{\\partial S}{\\partial \\hat{\\beta_0}} = \\sum_{i=1}^{n} (0 + 2\\hat{\\beta_0} + 0 - 2y_i - 0 + 2\\hat{\\beta_1}x_i)\n\\]\n\\[\n\\frac{\\partial S}{\\partial \\hat{\\beta_0}} = \\sum_{i=1}^{n} (2\\hat{\\beta_0} - 2y_i + 2\\hat{\\beta_1}x_i)\n\\]\nIgualando a 0\n\\[\n\\frac{\\partial S}{\\partial \\hat{\\beta_0}} = \\sum_{i=1}^{n} (2\\hat{\\beta_0} - 2y_i + 2\\hat{\\beta_1}x_i) = 0\n\\]\n\\[\n\\frac{\\partial S}{\\partial \\hat{\\beta_0}} = 2\\sum_{i=1}^{n} (\\hat{\\beta_0} - y_i + \\hat{\\beta_1}x_i) = 0\n\\]\nPodemos ainda realizar algumas simplificações.\nDividindo por 2 e multiplicando por -1\n\\[\n\\frac{\\displaystyle  2\\sum_{i=1}^{n} (\\hat{\\beta_0} - y_i + \\hat{\\beta_1}x_i)}{2} (-1) = \\frac{0}{2}(-1)\n\\]\n\\[\n\\sum_{i=1}^{n} (y_i - \\hat{\\beta_0} - \\hat{\\beta_1}x_i) = 0\n\\]\n\\[\n\\sum_{i=1}^{n}y_i - n\\hat{\\beta_0} - n\\hat{\\beta_1}\\sum_{i=1}^{n}x_i = 0\n\\]\nDividindo tudo por \\(n\\)\n\\[\n\\frac{\\displaystyle  \\sum_{i=1}^{n}y_i}{n} - \\frac{\\displaystyle  n\\hat{\\beta_0}}{n}-\\frac{\\displaystyle  n\\hat{\\beta_1}\\sum_{i=1}^{n}x_i}{n} = \\frac{0}{n}\n\\]\n\\[\n\\bar{y} - \\hat{\\beta_0} - \\hat{\\beta_1}\\bar{x} = 0\n\\]\nCom isso descobrimos que \\(\\displaystyle \\frac{\\partial S}{\\partial \\hat{\\beta_0}}\\) vale 0 quando\n\\[\n\\hat{\\beta_0} = \\bar{y} - \\hat{\\beta_1}\\bar{x}\n\\]\n\n\n\n\nDerivada paricla em relação à \\(\\hat{\\beta_1}\\)\nA derivada de \\(S\\) em relação a \\(\\hat{\\beta_1}\\) é\n\\[\n\\frac{\\partial S}{\\partial \\hat{\\beta_1}} = \\sum_{i=1}^{n} (0 + 0 + \\hat{\\beta_1}^2 x_i^2 - 0 - 2y_i\\hat{\\beta_1}x_i + 2\\hat{\\beta_0}\\hat{\\beta_1}x_i)\n\\]\n\\[\n\\frac{\\partial S}{\\partial \\hat{\\beta_1}} = \\sum_{i=1}^{n} (0 + 0 + 2\\hat{\\beta_1}x_i^2 - 0 - 2y_ix_i + 2\\hat{\\beta_0}x_i)\n\\]\n\\[\n\\frac{\\partial S}{\\partial \\hat{\\beta_1}} = \\sum_{i=1}^{n} (2\\hat{\\beta_1}x_i^2 - 2y_ix_i + 2\\hat{\\beta_0}x_i)\n\\]\n\\[\n\\frac{\\partial S}{\\partial \\hat{\\beta_1}} = 2\\sum_{i=1}^{n} x_i(\\hat{\\beta_1}x_i - y_i + \\hat{\\beta_0})\n\\]\nEssa é a derivada de S em relação a \\(\\hat{\\beta_1}\\). Agora igualamos a zero para encontrar o ponto de mínima.\n\\[\n\\frac{\\partial S}{\\partial \\hat{\\beta_1}} = 2\\sum_{i=1}^{n} x_i(\\hat{\\beta_1}x_i - y_i + \\hat{\\beta_0}) = 0\n\\]\nDividindo por 2 para simplificação\n\\[\n\\frac{\\displaystyle  2\\sum_{i=1}^{n} x_i(\\hat{\\beta_1}x_i - y_i + \\hat{\\beta_0})}{2} = \\frac{0}{2}\n\\]\n\\[\n\\sum_{i=1}^{n} x_i(\\hat{\\beta_1}x_i - y_i + \\hat{\\beta_0}) = 0\n\\]\n\\[\n\\sum_{i=1}^{n} x_i(-y_i + \\hat{\\beta_0} + \\hat{\\beta_1}x_i) = 0\n\\]\n\\[\n-\\sum_{i=1}^{n}x_iy_i + \\hat{\\beta_0} \\sum_{i=1}^{n}x_i + \\hat{\\beta_1}\\sum_{i=1}^{n}x_i^2 = 0\n\\]\nCom isso descobrimos que \\(\\frac{\\partial S}{\\partial \\hat{\\beta_1}}\\) vale 0 quando\n\\[\n\\hat{\\beta_0} \\sum_{i=1}^{n}x_i + \\hat{\\beta_1}\\sum_{i=1}^{n}x_i^2 = \\sum_{i=1}^{n}x_iy_i\n\\]\n\n\nEncontradas as derivadas, ainda falta resolvermos essas equações. A derivada de \\(S\\) em relação à \\(\\hat{\\beta_0}\\) ainda precisa de \\(\\hat{\\beta_1}\\) para ser resolvida, e o mesmo ocorre para \\(\\hat{\\beta_1}\\).\nUma solução para isso é substituir o valor de \\(\\hat{\\beta_0}\\) por \\(\\displaystyle \\bar{y} - \\hat{\\beta_1}\\bar{x}\\) na última equação apresentada acima. Essa substituição é valida pois estamos substituindo \\(\\hat{\\beta_0}\\) pelo seu valor que garante um resultado 0 para sua derivada.\nSubstituindo o valor de \\(\\hat{\\beta_0}\\) por \\(\\displaystyle \\bar{y} - \\hat{\\beta_1}\\bar{x}\\)\n\\[\n(\\bar{y}-\\hat{\\beta_1}\\bar{x})\\sum_{i=1}^{n}x_i + \\hat{\\beta_1}\\sum_{i=1}^{n}x_i^2 = \\sum_{i=1}^{n}x_iy_i\n\\]\nComo \\(\\bar{x} =\\displaystyle \\frac{\\displaystyle \\sum_{i=1}^{n}x_i}{n}\\), então \\(\\displaystyle \\sum_{i=1}^{n}x_i = n\\bar{x}\\).\n\\[\n(\\bar{y} - \\hat{\\beta_1}\\bar{x}) n\\bar{x} + \\hat{\\beta_1}\\sum_{i=1}^{n}x_i^2 = \\sum_{i=1}^{n}x_iy_i\n\\]\n\\[\nn\\bar{x}\\bar{y} - \\hat{\\beta_1}n\\bar{x}^2 + \\hat{\\beta_1}\\sum_{i=1}^{n}x_i^2 = \\sum_{i=1}^{n}x_iy_i\n\\]\n\\[\n-\\hat{\\beta_1}n\\bar{x}^2 + \\hat{\\beta_1}\\sum_{i=1}^{n}x_i^2 = \\sum_{i=1}^{n}x_iy_i - n\\bar{x}\\bar{y}\n\\]\n\\[\n\\hat{\\beta_1}(\\sum_{i=1}^{n}x_i^2 - n\\bar{x}^2) = \\sum_{i=1}^{n}x_iy_i - n\\bar{x}\\bar{y}\n\\]\n\\[\n\\hat{\\beta_1} = \\frac{\\displaystyle \\sum_{i=1}^{n}x_iy_i - n\\bar{x}\\bar{y}}{\\displaystyle \\sum_{i=1}^{n}x_i^2 - n\\bar{x}^2} \\qquad ou \\qquad \\hat{\\beta_1} = \\frac{\\displaystyle \\sum_{i=1}^{n}x_iy_i - \\frac{\\displaystyle \\sum_{i=1}^{n}x_i\\sum_{i=1}^{n}y_i}{n}}{\\displaystyle \\sum_{i=1}^{n}x_i^2 - \\frac{\\displaystyle (\\sum_{i=1}^{n}x_i)^2}{n}}\n\\]\nAgora, podemos encontrar o valor de \\(\\hat{\\beta_1}\\) que garante o menor valor de \\(S\\).\n\nx &lt;- d2h\ny &lt;- v\n\nn &lt;- length(x)\n\n#Serão chamados de b0.mqo e b1.mqo, para lembrarmos que são os valores obtido por meio das operações realizadas acima\nb1.mqo &lt;- (sum(x*y)-(sum(x)*sum(y))/n)/(sum(x^2)-(sum(x)^2)/n)\n\nb0.mqo &lt;- mean(y) - b1.mqo*mean(x)\n\nb0.mqo\n\n[1] -0.008682245\n\nb1.mqo\n\n[1] 0.001311559\n\n\nO caso mostrado acima foi montado com base na regressão linear simples, com somente os parâmetros \\(\\hat{\\beta_0}\\) e \\(\\hat{\\beta_1}\\). O sistema de equações normais nesse caso é disposto da seguinte forma\n\\[\n\\begin{cases} \\displaystyle  n\\hat{\\beta_0} \\enspace \\enspace \\quad + \\quad \\hat{\\beta_1}\\sum_{i=1}^{n}x_i \\quad = \\quad \\sum_{i=1}^{n}y_i \\\\\n\\displaystyle \\hat{\\beta_0}\\sum_{i=1}^{n}x_i \\quad + \\quad \\hat{\\beta_1}\\sum_{i=1}^{n}x_i^2 \\quad = \\quad \\sum_{i=1}^{n}y_ix_i \\end{cases}\n\\]\nPara uma regressão linear múltipla, com mais de uma variável explicativa, o processo é similar, porém adicionando-se mais uma equações ao sistema.\nEntretanto, quando muitas variáveis são adicionadas, convém dispor por meio de cálculo matricial. Essa disposição também é muito encontrada na literatura, e é comumente chamada de método análitico de resolução da regressão linear. As variáveis X, Y e os coeficientes assumem matrizes e vetores, como a seguir.\n\\(\\hat{\\beta}\\) é o vetor de parâmetros do modelo, de dimensão \\(p\\times 1\\). \\(Y\\) é o vetor da variável observada. Tem dimensão \\(n \\times 1\\). \\(\\epsilon\\) é o vetor de resíduos, de dimensão \\(n \\times 1\\). \\[\n\\mathbf{\\hat{\\beta}} = \\left[\\begin{array}{c}\n\\hat{\\beta_0} \\\\ \\hat{\\beta_1} \\\\ \\vdots \\\\ \\hat{\\beta_p}\n\\end{array}\\right]_{p\\times 1} \\qquad \\mathbf{Y} = \\left[\\begin{array}{c}\ny_1 \\\\ y_2 \\\\ \\vdots \\\\ y_n\n\\end{array}\\right]_{n \\times 1} \\qquad \\mathbf{\\epsilon} = \\left[\\begin{array}{c}\ne_1 \\\\ e_2 \\\\ \\vdots \\\\ e_n\n\\end{array}\\right]_{n \\times 1}\n\\]\n\\(X\\) é a matriz das variáveis explicativas do modelo, onde \\(n\\) é o número de observações, e \\(p\\) é o número de parâmetros do modelo. \\[\n\\mathbf{X} = \\left[\\begin{array}\n{cccc}   \n1 & X_{11} & X_{12} & \\dots & X_{1p} \\\\\n1 & X_{21} & X_{22} & \\dots & X_{2p} \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & X_{n1} & X_{n2} & \\dots & X{np} \\\\\n\\end{array}\\right]_{n \\times p}\n\\]\nAssim como no processo anterior, é desejado determinar o menor valor da soma de quadrado dos resíduos.\n\\[\nS = \\sum_{i=1}^{n} e_i^2 = \\epsilon^\\top \\epsilon\n\\]\n\\[\n\\epsilon^\\top \\epsilon = (Y - \\hat{\\beta}X)^\\top (Y - X\\hat{\\beta})\n\\]\n\\[\n= Y^\\top Y - Y^\\top (X\\hat{\\beta}) - (X\\hat{\\beta})^\\top Y + (X\\hat{\\beta})^\\top (X\\hat{\\beta})\n\\] \\[\n= Y^\\top Y - (X\\hat{\\beta})^\\top Y - (X\\hat{\\beta})^\\top Y + (X\\hat{\\beta})^\\top (X\\hat{\\beta})\n\\] \\[\n= Y^\\top Y - 2(X\\hat{\\beta})^\\top Y + (X\\hat{\\beta})^\\top (X\\hat{\\beta})\n\\] \\[\n\\mathbf{S} = Y^\\top Y - 2\\hat{\\beta}^\\top X^\\top Y + \\hat{\\beta}^\\top X^\\top X \\hat{\\beta}\n\\]\nA derivada parcial é dada por\n\\[\n\\frac{\\partial}{\\partial \\hat{\\beta}}[\\epsilon^\\top \\epsilon] = 0 \\enspace - \\enspace 2\\hat{\\beta}^\\top X^\\top Y \\enspace + \\enspace \\hat{\\beta}^\\top X^\\top X\\hat{\\beta} \\enspace = \\enspace 0\n\\]\n\\[\n0 - 2X^\\top Y + 2X^\\top X\\hat{\\beta} = 0\n\\]\n\\[\n2X^\\top X\\hat{\\beta} = 2X^\\top Y\n\\]\n\\[\nX^\\top X\\hat{\\beta} = X^\\top Y\n\\]\n\\[\n\\mathbf{\\hat{\\beta}} = (X^\\top X)^{-1} X^\\top Y\n\\]\nEssa é a equação que garante o menor valor de \\(S\\). Também podemos utilizá-la para encontrar os parâmetros.\n\nX &lt;- model.matrix(y ~ x)\n\nbetas &lt;- solve(t(X) %*% X) %*% t(X) %*% y\n\nbetas\n\n                    [,1]\n(Intercept) -0.008682245\nx            0.001311559\n\n\nE só para termos certeza de que tudo foi feito corretamente.\n\ncoef(lm(y ~ x))\n\n (Intercept)            x \n-0.008682245  0.001311559 \n\n\nAs três tentativas garantem o mesmo resultado.\n\n\n\n\n\n\nMQO\nMQO_Mat\nR\n\n\n\n\nB0\n-0.0086822\n-0.0086822\n-0.0086822\n\n\nB1\n0.0013116\n0.0013116\n0.0013116\n\n\n\n\n\n\n\nEsse é o método dos mínimos quadrados."
  }
]